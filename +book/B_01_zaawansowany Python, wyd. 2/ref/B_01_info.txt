B_01_info

1. Model danych
str 3 (34)

pythoniczność

przykład:
zamiast collection.len() stosuje się len(collection)

idiomatyczne funkcjonalności języka

formalizacja interfejsu bloków konstrukcyjych

str 5 (36)

------------------------------------
przykład P_1-1
------------------------------------

klasa FrenchDeck niejawnie dziedziczy z klasy obiekt, jej funkcjonalność nie jest dziedziczona,ale pochodzi z podległeo modelu danych i kompozycji. Dzięki implementacji metod specjalnych __len__ i __getitem__, klasa FrenchDeck zachowuje się jak standardowa sekwencja Pythona, pozwalając na korzystanie  z podstawowych funkcjonalności języka (np. iteracji i wycinania) oraz biblioteki standardowej, przykładem może być użycie funkcji random.choice, reversed i sorted
dzięki kompozycji implementacje metod __len__ i __getitem__ mogą delegowaćcałą pracę do obiektu list o nazwie self._cards


w aktualnej implenetacji talii FrenchDeck nie da się tasować - bo niezmienna: karty i ich pozycje nie mogą być zmieniane bez naruszenia hermetyzacjii bezpośredniej obsługi atrybutu _cards 
tasowanie - kiedyś tam! r 13

ważną cechą metod specjaln jest to że mają być wywoływane przez interpreter Pythona, a nie przez programistę.
nie piszemy my_object.__len__()
a piszemy len(my_object) -> gdy my_object jest wystąpieniem klasy zdefiniowanej przez użytkownika -> to Python wywoła zaimplementowaną metodę __len__

interpreter używa skrótu dla typów wbudowanych, takich jak list, str, bytearray lub rozszerzeń - takich jak tablice NumPy.

Kolekcje Pythona o zmiennym rozmiarze napisane są w C zawierają strukturę o nazwie PyVarObject, która zawiera pole ob_size - co jest znacznie szybsze od wywołania metody.

Najczęściej wywoływanie metod specjalnych odbywa się niejawnie.
dla przykładu: instrukcja for i in x: powoduje wywołanie funkcji iter(x), która z kolei może wywołac metodę x.__iter__(), jeśli jest ona dostępna, albo użyć x.__getitem__() - jak w przykładzie FrenchDeck

zwykle kod nie powinien zawierać zbyt wielu bezpośrednich wywołańmetod specjalnych.
o ile nie zajmujemy się metaprogramowaniem, powinnyśmy znacznie częściej implementować metody specjalne, niż wywoływać jest w sposób jawny.

Jedyną metodą specjalną która jest często wywoływana bezpośrednio w kodzie użytkownika jest metoda __init__.
służy ona do wywołania inicjatora klasy nadrzędnej we własnej implementacji metody __init__


jeśli potrzebujemywywołac metodę specjalną, zwykle lepiej jest wywołać związaną z nią funkcję wbudowaną (np. len, iter, str)
te wbudowane funkcję wywoują odpowiednią metodę specjalną, ale często dostarczają także inne usługi, poza tym w przypadku typów wbudowanych sa szybsze od wywołań metod


emulowanie typów numerycznych
reprezentacja tekstowa obiektów
wartość logiczna obiektów
implementowanie kolekcji



emulacja typów liczbowych

implementujemy klasę reprezentującą wektory dwuwymiarowe -> wektory euklidesowe

do replezentacji wektorów dwuwymiarowych wystarałby typ complex - lecz naszą klasę chcemy poszerzyć aby reprezentowała wektory n-wymiarowe

projekt interfejsu API dla klasy
symulowana wersja sesji konsoli

v1 = Vector(2, 4)
v2 = Vector(2, 1)
v1 + v2
Vector(4, 5)

operator + tworzy wynik w postaci Vector i wyświetlany jest w postaci Vector(4, 5)

wbudowana funkcja abs zwraca wartość bezwzględną liczb całkowitychi zmiennoprzecinkowych
orz moduł liczb zespolonych- complex

aby zachować spójność w API również użyjemy funkcji abs do obliczenia modułu wektora:

v = Vector(3, 4)
abs(v)
5.0


implementacja operatora * - mnożenie przez skalar (tj. przez liczbę)

v * 3
Vector(9, 12)
abs(v * 3)
15.0

przykłąd 1-2 klasa Vector która ma zaimplementowane operacje dzięki użyciu metod specjalnych __repr__, __abs__, __add__ i __mul__

------------------------------------
przykład P_1-2
------------------------------------

żadna z zaimplementowanych metod nie jest bezpośrednio wywoływana wewnątrz klasy
są one wywoływane przez interpreter Pythona

w przykładzie mamy zaimplementowa operatory + oraz * - co pokazuje podstawowe użycie metod __add__ oraz __mul__
w obu przypadka metody zwracają nową instancję klasy Vector i niemodyfikują żadnego operandu - self i other są jedynie odczytywane.
jest to oczekiwane zachowanie operatorów infiksowych -> tworzą nowe obiekty, nie modyfikują operandów


reprezentacja tekstowa

metoda specjalna __repr__ jest wywoływana przez wbudowaną funkcję repr, aby otrzymać reprezentację tekstową obiektu do inspekcji.

jeśli metoda __repr__ nie będzie zaimplementowana, wystąpienia wektorów byłyby pokazana w konsoli w taki sposób

<Vector object at 0x10f5a0c10>

konsola oraz debugger wywołują funkcje repr na wynikach przetważanych wyrażeń, taj jak to robi symbol zastępczy %r w klasycznym formtowaniu z operatorem % i pole konwersji !r w nowej składn formatowania

https://docs.python.org/3.10/library/string.html#format-string-syntax
Format String Syntax

używanej przez f-strings w metodzie str.format


użyte f-string w naszej implementacji __repr__ używa !r

return f'Vector({self.x!r}, {self.y!r})'

do otrzymania standardowejreprezentacji atrybutówdo wyświetlenia.
jest istotna różnica w pokazywaniu Vector(1, 2) a Vector('1', '2') - oczywiście drugi przypadek nie działałby gdyż argumentami onstruktora muszą być liczby, a nie łańcuchy

Łańcuch znaków zwracany przez __repr__ powinien być jednoznacznyi o ile możliwe odpowiadać kodowi źródłowemu koniecznemu do ponownego utworzenia reprezentowanego obiektu

w naszym przykładzie wybrana reprezentacja wygląda tak jak wywołnie konstruktora klasy
np. Vector(3, 4)

metoda __str__ jest wywoływana przez wbudowną funkcję str() i niejawnie używan w funkcji print()

metoda __str__ powinna zwracać łańcuch odpowiedni do wyświtlenia dla użytkowników końcowych.

 w przypadku implementacji tylko jednej z tych metod specjalnych (___str__, __repr__) korzystniej wybrać __repr__, gdyż nie ma dostępnej niestandardowej metody __str__.
 Python wywoła __repr__ jako metoę rezerwową
 
 
 What is the difference between __str__ and __repr__?
 https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr
 
 
 
 
 Wartość logiczna trybu niestandardowego
 
 typ wbudowany w Pythonie to bool, lecz jest akceptowany dowolny obiekt w kontekstach logicznych, takich ja 
 wyrażenia kontrolujące instrukcje - if, while, operandy operatorów and, or i not.
 
 aby wyznaczy czy wartość x jest truthy czy falsy, Python stosuje bool(x), co zawsze zwraca True lub False.
 
 Domyślne wystąpienia klas definiowanych przez użytkownika są uważana jako truthy, o ile nie mają zaimplementowanych metod __bool__ ani __len__
 
 zasadzniczo bool(x) wywołuje x.__bool__i wykorzystuje wynik tej metody.
 jeś metoda __bool__ nie jest zaimplementowana Python próbuje wywołać metodę x.__len__(), a jeśli ona zwraca zero, to bool zwraca False, w przeciwnym razie boo zwraca True.
 
 w naszym przykładzie implementacja metody __bool__jest koncepcyjnie prosta - zwraca False gdy moduł wektora jest równy zero, a w przeciwnym wypadku True.
 
 konwertujemy moduł na Boolean przy użyciu bool(abs(self)) - ponieważ metoda __bool__ ma zwracać zgodnie z oczekiwaniem typ logiczny.
 
poza metodą __bool__ rzadko zdarza się konieczność jawnego wywołania bool(), gdyż każdego obiektunayć w kontekscie logicznym.

można zauważyć że specjalna metoda __bool__ pozwala obiektom na spójność z regułami testowania wartości prawdy które są zdefiniowane w dokumentacji Pythona -

Truth Value Testing
https://docs.python.org/3/library/stdtypes.html#truth

można też wykreować szybszą implementację Vector.__bool__

def __bool__(self):
	return bool(self.x or self.y)
	

API kolekcji

interfejs podstawowych typów kolekcji występujących w języku
wszystkie klasy to ABC - abstrakcyjne klasy bazowe.

każda z najwyższych klas ABC zawiera pojedynczą metodę specjalną.
klasa ABC Collection - od Pythona 3.6 - unifikuje trzy kluczowe interfejsy, które powinna implementować każda kloekcja 

- Iterable - obsługa for, rozpakowywania* i innych form iteracji

	     * 4.8.5. Unpacking Argument Lists
	       https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists

- Sized - wsparcie wbudownej funkcji len
- Container - obsługa operatora in

Python nie wymaga od konkretnych klas, aby rzeczywiście wywodziły się z której kolwiekz tych klas ABC

Dowolna klasa implementująca __len__ spełnia wymagania interfejsu Sized

Ważne specjalizacje Collection:

Sequence - formalizuje interfejs wbudowanych funkcji, takich jak list i str
Mapping - implementowane przez dict, collections.deaultdict itp
Set - interfejs typów wbudowanych set i frozenset

tylko klasa Sequence jest Reversible - gdyż sekwencje wspierają dowolne porządkowanie swojej zawartości- czego nie obsługują odwzorowania ani zbiory

począwszy od Pythona 3.7 dict jest oficjalnie uporządkowany - tzn. zachowana jest kolejność wstawiania kluczy - nie można zmienić kolejności kluczy w dict wg własnego życzenia

przegląd metod specjalnych

Data model
https://docs.python.org/3/reference/datamodel.html

2. Tablica sekwencji

Python odziedziczył z ABC (językiem ABC) ujednoliconą obsługę sekwencji

Łańcuchy, listy, sekwencje bajtów, tablice, elementy XML i wyniki baz danych współdzielą bogaty zbiór operacji, obejmujący iteracje, wycinanie, sortowanie i łączenie 

zrozumienie list oraz podstawy wyrażeń generatorów
używanie krotek jako rekordów kontra ich wykorzystywanie jako niezmiennych list
rozpakowywanie sekwencji i wzorce sekwencji
czytanie i zapisywanie wycinków
specjalizowane typy sekwencji, jak tablice i kolejki


zarządzanie uporządkowanymi sekwencjami za pomocą bisect
https://www.fluentpython.com/extra/ordered-sequences-with-bisect/

przegląd wbudowanych sekwencji

biblioteka standardowa oferuje wiele typów sekwencji zaimplementowanych w języku C:

Sekwencje kontenerowe - przechowują elementy różnych typów, włącznie z innymi kontenerami
np. list tuple i collections.deque

Sekwencje płaskie - przechowują elementy jednego typu
np. str, bytes i array.array

Sekwencje kontenerowe - przechowują odwołania do zawartych w sobie obiektów, które mogą być dowolnego typu

sekwencje płaskie są bardziej upakowane, lec przy tym ograniczone do przechowywania prymitywnych wartości - takich jak znaki, bajty i liczby

każdy obiekt Pythona w pamięcia zawiera nagłówek z metadanymi
najprostszy obiekt Pythona - float, ma pole wartości oraz dwa pola metadanych:
ob_refcnt - licznik referencji do obiektu
ob_type - wskaźnik do typu obiektu
ob_fval - liczba double języka C, przechowywująca wartość

https://docs.python.org/3/c-api/typeobj.html#slot-type-typedefs

w 64-bitowe kompilacji Pythona każde z tych pól zajmuje 8 bajtów.

tablica float jest bardziej zwarta, niż krotka z tymi samymi wartościami.
tablica to pojedynczy obiekt przechowywujący surowe wartośc, podcas gdy krotka składa się z wielu obiektów - siebie samej oraz każdego obiektu float w niej zawartego


innym sposobem grupowania sekwencji jest ich zmienność

Sekwencje zmienne
list byte.array, array.array, i collections.deque

Sekwencje niezmienne
tuple, str i bytes



Wyrażenia listowe i wyrażenia generatora
szybkim sposobem na zbudowanie sekwencji jest użycie wyrażenia listowego - gdy celem jest list - lub wyrażenia generatora - dla wszystkich innych rodzajów sekwencji.

nie używając tych form syntaktycznych - nasz kod jest mniej czytelny, również mniej szybszy

w środowisku Pythona
wyrażenia listowe - to listcomp
wyrażenia generatora - to genexp

Przykład 2-1

Przykład 2-2

bardziej czytelny przykładem jest przykład 2-2


zastosowanie pętli for
do skanowania sekwencji, aby zliczać lub wybierać elementy
obliczanie agregacji - sum, średnich
przetwarzanie

kod 2-1 buduje listę
w 2-2 jest zastosowane wyrażenie listowe - jego zadaniem jest budowanie listy

w przypadku stosowania wyrażeń listowych, należy brać pod uwagę aby to wyrażenie nie miało więcej niż dwa wiersze i było zwięzłe


w kodzie Pythona podziały wierszy są ignorowane wewnątrz parnawiasów []{} lub ()
jest możliwe budowanie wielowierszowych list, wyrażeń listowych i generatorów, słowników itp. bez używania znaku ucieczki \ do oznaczania kontynuacji wiersza.
stosując \ nie wolno umieścić po nim żadnego znaku - nawet spacji

kodując wielowierszowy literał listowy należ zadbać aby po ostatniej pozycji umieścić przecinek -
aby nie tworzyć zamętu przy wyszukiwaniu różnic


---------------------------------------------------
Lokalny zasięg w wyrżeniach listowych i generatora

w Pytchonie 3 wyrażenia listowe, wyrażenia generatora, wyrażenia zbiorów - setcomp - oraz słownikowe - dictcomp, mają zasięg lokalnydo przechowywania zmiennych przypisanych w klauzuli for

zmienne przypisane za pomocą 'operatora morsa' := pozostają dostępne po powrocie z tych wyrażeń - w przeciwieństwie do lokalnych zmiennych funkcji

PEP 572 – Assignment Expressions
https://peps.python.org/pep-0572/

przykład 1

x = 'ABC'
codes = [ord(x) for x in x]
x
'ABC'
codes
[65, 66, 67]

x - jest powiązany z 'ABC' - nie jest oderwany

przykład 2

codes = [last := ord(c) for c in x]
last
67
c
Traceback (most recent call last):
  File "/snap/pycharm-community/323/plugins/python-ce/helpers/pydev/pydevconsole.py", line 364, in runcode
    coro = func()
  File "<input>", line 1, in <module>
NameError: name 'c' is not defined

last jest widoczne poza zakresem
c - nie jest widoczne poza zakresem

---------------------------------------------------

wyrażenia listowe budują listy na podstawie sekwencji lub dowolnego innego typu iterowalnego za pomocą filtrowania i transformcji elementów.
to samo można realizować za moca wbudowanych funkcji filter i map


Wyrażenia listowe a funkcje filter i map

Przykład 2-3
budowanie listy  za pomocą wyrażenia listowego i złożenia funkcji map-filter

>>> symbols = '$¢£¥€¤'
>>> beyond_ascii = [ord(s) for s in symbols if ord(s) > 127]
>>> beyond_ascii
[162, 163, 165, 8364, 164]



>>> beyond_ascii = list(filter(lambda c: c > 127, map(ord, symbols)))
>>> beyond_ascii
[162, 163, 165, 8364, 164]



test szybkości 
https://github.com/fluentpython/example-code-2e/blob/master/02-array-seq/listcomp_speed.py

Iloczyny kartezjańskie
wyrażenia listowe mogą generować listy na podstawie iloczynu kartezjańskiego dwóch obiektów iterowalnych lub większej ich liczby.

elementy składające się na iloczyn kartezjański to krotki powstałe z elementów pochodzących z każdego wejściowego obiektu iterowalnego.

wynikowa lista ma długość równą przemnożonym długością wejściowych obiektów iterowalnych

iloczyn kartezjański sekwencji trzech wartości kart i sekwencji czterech kolorów, w wyniku daje sekwencję dwanastu par

 
przykład iloczynu kartezjańskiego z zastosowaniem wyrżeni listowego

>>> colors = ['black', 'white']
>>> sizes = ['S', 'M', 'L']
>>> tshirts = [(color, size) for color in colors for size in sizes]
generuje listę krotek uporządkowanych wg koloru - color, a następnie rozmiaru - size
>>> tshirts
[('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), ('white', 'M'), ('white', 'L')]

taka lista jest porządkowana tak, jakby pętle for były zagnieżdżone w tej samej kolejności, w jakiej występują w wyrażeniu listowym

>>> for color in colors:
...     for size in sizes:
...             print((color, size))
... 
('black', 'S')
('black', 'M')
('black', 'L')
('white', 'S')
('white', 'M')
('white', 'L')

aby uporządkować elementy wg rozmiaru, a następnie koloru, należy zmienić kolejność klauzul for.
zmiana sposobu zapisu wyrażenia listowego poprawia czytelność wyrażenia

>>> tshirts = [(color, size) for size in sizes
...                          for color in colors]
>>> tshirts
[('black', 'S'), ('white', 'S'), ('black', 'M'), ('white', 'M'), ('black', 'L'), ('white', 'L')]


w przykładzie 1-1
    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]
        
dla poprawienia czytelności = można ją zapisać:

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits 
        				for rank in self.ranks]
        				

wyrażenia listowe mają tylko jedno zastosowanie: budują listy
        

wyrażenia generatora

do inicjalizacji krotek, tablic i innych typów sekwencji możemy początkowo używać także wyrażeń listowych , lecz wyrażenia generatora oszczędzają pamięć - generują pojedyncze elementy przy użyciu protokołu iteratora, zamiast budować całą listę  tylko po to, by załadować ją do innego konstruktora

wyrażenia generatora korzystają z tej samej składni co wyrażenia listowe, ale są zawarte w nawiasach okągłych  a nie kwadratowych

podstawowe użycie wyrażeń generatora do budowania krotki i tablicy

inicjowanie krotki i tablicy za pomocą wyrażenia generatora

>>> symbols = '$¢£¥€¤'
>>> tuple(ord(symbol) for symbol in symbols)
(36, 162, 163, 165, 8364, 164)

jeśli wyrażenie generatora stanowi pojedynczy argument w wywołaniu funkcji, nie ma potrzeby dublowania nawiasów otaczających

>>> import array
>>> array.array('I', (ord(symbol) for symbol in symbols))
array('I', [36, 162, 163, 165, 8364, 164])

konstruktor array przyjmuje dwa argumenty, więc nawiasy wokół wyrażenia generatora są obowiązkowe.

pierwszy argument konstruktora array definiuje typ służący do przechowywania liczb w tablicy.

Przykład 2-6
Iloczyn kartezjański w wyrażeniu generatora
 
>>> colors = ['black', 'white']
>>> sizes = ['S', 'M', 'L']
>>> for tshirt in ('%s %s' % (c, s) for c in colors for s in sizes):
...     print(tshirt)
... 
black S
black M
black L
white S
white M
white L

wyrażenie generatora wytwarza elementy pojedynczo.
w tym przykładzie lista sześciu odmian koszulek nie powstaje


Krotki
krotki mogą służyć jako niezmienne listy, ale także jako rekordy bez nazw pól.

Krotki jako rekordy

krotki przechowuj rekordy - każdy element w krotce przechowuje dane jednego pola, a położenie tego elementu wyznacza jego znaczenie.

jeśli krotki mają być uważane jako niezmienne listy - to nalezy uważać, że liczba i kolejność elementów w zależności od kontekstu może, ale nie musi być istotna.

jeśli krotki używamy jako kolekcji pól, liczba elementów jest często stała, a ich kolejność zawsze ważna.

przykład 2-7
zastosowanie krotki jako rekordy

>>> lax_coordinates = (33.9425, -118.408056)
szerokość i długość geograficzna lotniska międzynarodowego w Los Angeles

city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)
dane dotyczące Tokyo: nazwa, rok, populacja (w mln), zmiana populacji (%), obszar (km2)

>>> traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205856')]
lista krotek zawierających kod krajui numer paszportu w formie (country_code, passport_numbeer)


>>> for passport in sorted(traveler_ids):
...     print('%s/%s' % passport)
... 
BRA/CE342567
ESP/XDA205856
USA/31195855

podczas iteracji zmienna passport wiązana jest z poszczególnym krotkami

'%s/%s' % passport - operator formatujący % rozumie krotkii traktuje każdy element jako oddzielne pole

>>> for country, _ in traveler_ids:
...     print(country)
... 
USA
BRA
ESP

pętla for wie jak oddzielnie pobierać elementy z krotek - jest to nazywane rozpakowywaniem 
w tym przykładzie drugi element jest nie istotny - wobec tego jest przypisany do zmiennej fikcyjnej

często uważa się rekordy jako struktury danych z nazywanymi polami.
w ww przykładzie mamy taką strukturę:

city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)

jest to przykład rozpakowywania krotek



krotki jako niezmienne listy

interpreter Pythona oraz biblioteka standardowa szeroko wykorzystują krotki jako niezmienne listy 

korzyści:

przejrzystość - w kodzie długość krotki się nigdy nie zmien

wydajność - krotka zajmuje mniej pamięci, niż lista o tej samej długości - co pozwala Pythonowi dokonać pewnych optymalizacji

niezmienność krotki dotyczy tylko referencji, które zawiera.

zawartość krotki jako takiej jest niezmienna, oznacza to, że przechowywane w niej referencje zawsze będą wskazywać te same obiekty.
jeśli jeden ze wskazywanych obiektów jest zmienny - np. lista - jego zawartość może sie zmienić.

>>> a = (10, 'alpha', [1, 2])
>>> b = (10, 'alpha', [1, 2])
>>> a == b
True
>>> b[-1].append(99)
>>> b
(10, 'alpha', [1, 2, 99])
>>> a == b
False


jak określić jawnie, czy krotka (lub dowolny inny obiekt) ma ustaloną wartość, można użyć wbudowanej funkcji hash 
obiekt jest hashowalny jedynie wtedy gdy jego wartość nigdy nie może sie zmienić.
niehashowalnej krotki nie można wstawić jako kluca do słownika - dict ani elementu zbioru - set

przykład funkcji która jawnie okresla czy krotka (lub dowolny inny obiekt) ma ustaloną wartość, używając wbudowanej funkcji hash()

>>> def fixed(o):
...     try:
...             hash(o)
...     except TypeError:
...             return False
...     return True
... 
>>> tf = (10, 'alpha', (1, 2))
>>> tm = (10, 'alpha', [1, 2])
>>> fixed(tf)
True
>>> fixed(tm)
False

w pewnym sensie jest to pułapka - nie wychwycenie - czy krotka jest ze zmiennymi elementami 

-->
https://stackoverflow.com/questions/68630/are-tuples-more-efficient-than-lists-in-python/22140115#22140115

Are tuples more efficient than lists in Python?
Czy w Pythonie krotki są wydajniejsze od list?

przy przetworzeniu literału krotki, Python generuje kod bajtowy dla stałej krotkowej w jednej operacji
dla literału listy kod bajtowy wypycha każdy element jako oddzielną stałą na stos danych, po czym buduje listę.

dla danej krotki t zwraca referencję do samego t.
nie ma potrzeby kopiowania 
dla listy l konstruktor list(l) musi utworzyć nową kopię l.

dzięki określoej długości instancja krotki ma alokowane dokładnie tyle pamięci, ile potrzebuje

referencje do elementów w krotce przechowywane są w tablicy w strukturze krotki.
lista utrzymuje wskaźnik do tablicy referencji przechowywanej w innym miejscu.
jest to istotne gdyż lista rozrastając się ponad wielkość aktualnie alokowanej przestrzeni, Python musi realokowoać tablicę referencji, aby zrobić miejsce.
takie podejście sprawia, że pamieć podręczna procesora jest mniej efektywna.


porównanie metod krotek i list

krotki obsługują wszytkie metody list, które nie obejmują dodawania ani usuwania elementów, krotki nie mają metody __reversed__ lecz działa na nie funkcja reversed(krotka)



rozpakowywanie sekwencji i typów iterowalnych

rozpakowywanie pozwala uniknąć niepotrzebnego i podatnego na błędy używania indeksów w celu wydobywanie=a elementów z sekwencji

rozpakowywanie działa z dowolnym iterowalnym obiektem jako źródłem danych - wyłącznie z iteratorami, które nie obsługują notacji indexowej ([])

jedynym wymogiem jest to, że typ iterowalny zwraca dokładnie jeden element na zwienną po stronie odbierającej, o ile nie zostanie użyta gwiazdka (*) do przechwycenia nadmiarowych elementów

najbardziej widoczna forma rozpakowywania to przypisywanie równoległe - przypisywanie elementów typu iterowalnego do krotki zmiennych

>>> lax_coordinates = (33.9425, -118.408056)
>>> latitude, longitude = lax_coordinates
>>> latitude
33.9425
>>> longitude
-118.408056
>>> 

zastosowanie rozpakowywania poprzez zamianę wartości zmiennych  bez użycia zmiennej tymczasowej

>>> b, a = a, b

rozpakowywanie jest poprzedzone argumentu gwiazdką (*) przy wywołaniu funkcji

>>> divmod(20, 8)
(2, 4)
>>> t = (20, 8)
>>> divmod(*t)
(2, 4)
>>> quotient, remainder = divmod(*t)
>>> quotient, remainder
(2, 4)
>>> 

funkcja zwraca wiele wartości w sposób wygodny dla wywołującego.

przykładem może być funkcja os.path.split() - buduje ona krotkę (path, last_part) ze ścieżki systemu plików:


>>> import os
>>> _, filename = os.path.split('/home/luciano/.ssh/id_rsa.pub')
>>> filename
'id_rsa.pub'
>>> 

używanie * do przechwytywania nadmiarowych elementów

definiowanie parametrów funkcji przy użyciu *args w celu przechwyceni dowolnych nadmiarowych argumentów jest klasyczną cechą Pythona.

w Pythonie 3 idea została rozszerzona również na przypisanie równoegłe

>>> a, b, *rest = range(5)
>>> a, b, rest
(0, 1, [2, 3, 4])
>>> 
>>> a, b, *rest = range(3)
>>> a, b, rest
(0, 1, [2])
>>> 
>>> a, b, *rest = range(2)
>>> a, b, rest
(0, 1, [])


prefix * może być zastosowany do dokoładnie jednej zmiennej, ale może się pojawić na dowolnej pozycji

>>> a, *body, c, d = range(5)
>>> a, body, c, d
(0, [1, 2], 3, 4)
>>> 
>>> *head, b, c, d = range(5)
>>> head, b, c, d
([0, 1], 2, 3, 4)

rozpakowywanie z * w wywołaniach funkcjii literałach sekwencji

https://peps.python.org/pep-0448/
wprowadzona bardziej elastyczną składnię dla rozpakowania iterowalnych

https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations

w wywołaniach funkcji możemy użyć * wiele razy:

>>> def fun(a, b, c, d, *rest):
...     return a, b, c, d, rest
... 
>>> fun(*[1, 2], 3, *range(4, 7))
(1, 2, 3, 4, (5, 6))

Gwiazdka * może również zostać być użyta przy definiowania literałówlist, tupli lub set:

>>> *range(4), 4
(0, 1, 2, 3, 4)
>>> 

>>> [*range(4), 4]
[0, 1, 2, 3, 4]
>>> 

>>> {*range(4), 4, *(5, 6, 7)}
{0, 1, 2, 3, 4, 5, 6, 7}
>>> 

rozpakowywanie krotek działa również z zagnieżdżonymi strukturami.



Zagnieżdżone rozpakowywanie


Rozpakowywanie zagnieżdżonych krotek w celu dostępu do długości geograficznej:

Przykład 2-8
każda krotka przechowuje rekord z czterema polami, przy czym ostatnie pole to para współrzędnych
 ('Tokyo', 'JP', 36.933, (35.689722, 139.691667))

poprzez przypisanie ostatniego pola do zagnieżdżonej krotki rozpakowujemy współrządne
for name, _, _, (lat, lon) in metro_areas: 
	...

test lon <= 0: wybiera jedynie miasta z zachodniej półkuli
if lon <= 0: 
	...

>>> metro_areas = [
...     ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),
...     ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
...     ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
...     ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
...     ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)),
... ]
>>> def main():
...     print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')
...     for name, _, _, (lat, lon) in metro_areas: 
...             if lon <= 0: 
...                     print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')
... 

>>> main()

                |  latitude | longitude
Mexico City     |   19.4333 |  -99.1333
New York-Newark |   40.8086 |  -74.0204
São Paulo       |  -23.5478 |  -46.6358


obiektem docelowym przypisania rozpakowywującego może być lista
mogą to być zapytania bazodanowe zwracający pojedynczy rekord - np. kod SQL zawierający klauzulę LIMIT 1
[record] = query_returning_single_row()
po zapisaniu w wykorzystaniem krotek - byłby zapis (record,)

gdy rekord zawiera tylko jedno pole, możemy je otrzymać bezpośrednio:
[[field]] = query_returning_single_row_with_single _field()
po zapisaniu z wykorzystaniem krotek - ((field,),)

w obu przypadkach istotny jest przecinek


Dopasowanie wzorców w sekwencjach

nową funkcjonalnością Pythona 3.10 jest dopasowywanie wzorców oparte na instrukcji match/case

PEP 634 – Structural Pattern Matching: Specification
Strukturalne dopasowywanie wzorców

https://peps.python.org/pep-0634/

https://docs.python.org/3.10/whatsnew/3.10.html#pep-634-structural-pattern-matching
https://docs.python.org/3.10/whatsnew/3.10.html


Przykład 2-9
przykład użycia match/case
- metoda z fikcyjnej klasy robot

match message: -> wyrażenie po słowie kluczowym match to temat(subject) - są to dane, które Python będzie próbował dopasować do wzorców w każdej klauzuli case

def handle_command(self, message):
	match message:
		case ['BEEPER', frequency, times]:
		# **1
			self.beep(times, frequency)
			
		case ['NECK', angle]:
		# **2
			self.rotate_neck(angle)
			
		case ['LED', ident, intensity]:
		# **3
			self.leds[ident].set_brightness(ident, intensity)
		
		case ['LED', ident, red, green, blue]:
		# **4
			self.leds[ident].set_color(ident, red, green, blue)
		case _:
		# **5
			raise InvalidCommand(message)
			
**1
ten wzorzec pasuje do każdego tematu, który jest sekwencją trzech elementów
- 'BEEPER'
- kolejne dwa mogą być czymkolwiek i zostaą przypisane do zmiennych frequency oraz times

**2
dopasowanie do dowolnego tematu z dwoma elementami, z których pierwszym jest 'NECK'

**3
to pasuje do tematu z trzema elementami zaczynającymi się od 'LED'
jeśli liczba elementów nie pasuje, Python przejdzie do nastęnej klauzuli case

**4 
kolejny wzorzec 'LED' z pięcioma elementami

**5
domyślny przypadek
zostanie dopasowany do dowolnego tematu, który nie został dopasowany wcześniej
zmienna _ jest specjalna.


jednym z kluczowych ulepszeń match/case jest destrukturyzacja - bardziej zaawansowana forma rozpakowywania - jest to nowość w Pythonie


Przykład 2-10
zmodyfikowano Przykład 2-8

>>> metro_areas = [
...     ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),
...     ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
...     ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
...     ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
...     ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)),
... ]
>>> def main():
...     print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')
...     for record in metro_areas: 
	       # tematem jest każda z krotek metro_areas
		
		match record: 
			case [name, _, _, (lat, lon)] if lon <= 0:
			     # klauzula case ma 2 części:
			     # wzorzec oraz opcjonalny strażnik 
			     # - zabezpieczenie po słowie kluczowym if
			     
...         	print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')
... 
>>> main()

wzorzecz [name, _, _, (lat, lon)] pasuje do sekwencji o czterech elementach - lecz ostatni element musi być sekwencją dwuelementową.

wzorce sekwencji mogą być krotka listami, dowolną kombinacją zagnieżdżonych krotek i list 
użycie nawiasów () lub [] we wzorcach zagnieżdżonych nie ma większego znaczenia mogą występować wymiennie

wzorzec sekwencji może pasować do wystąpień wiekszości rzeczywistych lub wirtualnych podklas collections.abc.Sequence, z wyjątkiem str, bytes i bytearray

wystąpienia str, bytes i bytearray nie są obsługiwane jako sekwencje w kontekście match/case


jeśli chcemy użyć obiektu jesdnego z typów (str, bytes, bytearray) to należy go przekonwertować w klauzuli match
przykład:
	phone - jest traktowane jako jedna wartość a nie sekwencja cyfr
	
	match tuple(phone):
		case ['1', *rest]:
			...
		case ['2', *rest]:
			...
		case ['3' | '4', *rest]:
			...
			

typy biblioteki standardowej które są kompatybilne ze wzorcami sekwencji

	list	memoryview	array.array
	tuple	range		collections.deque

https://docs.python.org/pl/3.10/c-api/memoryview.html#index-0

w przeciwieństwie do rozpakowywania, wzorce nie destrukturyzują obiektów iterowalnych, które nie są sekwencjami (jak iteratory)

symbol _ ma specjalne znaczenie we wzorcach: dopasowuje dowolny pojedynczy element na tej pozycji, ale nigdy nie jest powiązany z wartością dopasowywanego elementu.
ponadto _ jest jedyną zmienna, która może sie pojawić we wzorcu więcej niż raz


można powiązać dowolną część wzorca ze zmienną za pomocą słowa kluczowego as:
	case [name, _, _, (lat, lon) as coord]:
	
przyjmując że temat to ['Shanghai', 'CN', 24.9, (31.1, 121.3)] wcześniejszy przykład zostanie dopasowany i ustawi następujące zmienne

Zmienna		Ustawiana wartość
name		'Shanghai'
lat		31.1
lon		121.3
coord 		(31.1, 121.3)

wzorce można uczynić bardziej szczegółowymi poprzez dodanie informacji o typie.

poniższy wzorzec dopasowuje tę samą strukturę zagnieżdżoną, co poprzedni, lecz pierwszy element musi być wystąpieniem typu str, a obydwa elemenjty dwuelementowej krotki muszą być wystąpieniemi float:

	case [str(name), _, _, (float(lat), float(lon))]:
	
ogólnie wyrażenia str(name) oraz float(lat) wyglądają podobnie jak wywołania konstruktora, które używa sie do przekonwertowania name oraz lat na typy str i float

lecz w kontekście wzorca składnia ta wykonuje sprawdzenie typu w czasie działania, ten wzorzec dopasowuje sekwencję o czterech elementach, której element 0 musi być typu str, a element 3 musi być parą liczb zmiennoprzecinkowych
element 0 zostanie powiązany ze zmienną name, a liczby z elementu 3 zostana powiązane odpowiednio ze zmiennymi lat i lon  

możemy dopasować dowolny temat sekwencji rozpoczynający sie od str i kończący się na zagnieżdżonej sekwencji dwóch liczb float:

	case [str(name), *_, ((float(lat), float(lon)]:
	
*_ dopasowuje dowolną liczbę elementów bez wiązania ich ze zmiennymi

użycie napisu *extra zamiast *_ spowoduje powiązanie tych elementow do zmiennej extra jako listy zawierające 0 lub wiecej elementów

opcjonalna klauzula strażnika rozpoczynająca się od if jest przetwarzana tylko wtedy, gdy wzorzec zostanie dopasowany i może odwoływać sie do zmiennych powiazanych we wzorcu, jak w przykładzie 2-10

		match record: 
			case [name, _, _, (lat, lon)] if lon <= 0:						     
...         	print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')

zagnieżdżony blok z instrukcją print jest wykonywany tylko wtedy, gdy wzorzorzec jest dopasowany i wyrażenie strażnika jest prawdziwe

przykłady match/case

https://github.com/gvanrossum/patma/blob/3ece6444ef70122876fd9f0099eb9490a2d630df/EXAMPLES.md#case-6-a-very-deep-iterable-and-type-match-with-extraction

przykład 2-10 nie jest ulepszeniem przykładu 2-8.

są to przykłady 2 sposobów na realizację tej samej rzeczy


dopasowanie wzorców sekwencji w interprzeterze 


https://github.com/fluentpython/lispy/blob/main/original/norvig/lis.py
http://norvig.com/lispy.html

w powyższym kodzie istotnymi funkcjami jest parse i evaluate (eval - w oryginale)

jest podana komenda parse('(gcd 18 45)')


>>> s = '(gcd 18 45)'
>>> s.replace('(',' ( ').replace(')', ' ) ').split()
['(', 'gcd', '18', '45', ')']

i wynikiem działania parse jest
['gcd', 18, 45]

te dane trafiają do evaluate ['gcd', 18, 45] ta przetwarza funkcję gcd z argumentami 18 i 45.
w wyniku przetwarzania oblicza największy wspólny dzielnik argumentów: 9

parse(''' 
	(define double
		(lambda (n)
			(* n 2)))
''')
wynik:
['define', 'double', ['lambda',['n'], ['*', 'n', 2]]]

tu mamy definicję funkcji o nazwie double z parametrem n.
Ciałem tef funkcji jest wyrażenie (* n 2) - wynikiem wywołania funkcji w Scheme jest wartość ostatniego wyrażenia w jej ciele



destrukturyzacja sekwencji - jak działa evaluator

przykład 2-11
dopasowywanie wzorców bez match/case


def evaluate(exp: Expression, env: Environment) -> Any:
	"Ewaluate an expression in an environment."
	
	if isinstance(exp, Symbol):
	    # referencja do zmiennej
		return env[exp]
		
	elif isinstance(exp, list):
		# literał do stałej
		return exp
	
	# ...
	
	elif exp[0] == 'quote':
		# (wyrażenie quote)
		(_, x) = exp
		return x
		
	elif exp[0] == 'if':
		# (if test kontynuacja alternatywa)
		(_, test, consequence, alternative) = exp
		if evaualate(test, env):
			return evaluate(consequence, env)
			
	elif exp[0] == 'lambda':
		# (lambda (parametry) ciało)
		(_, parms, *body) = exp
		return Procedure(parms, body, env)
		
	elif exp[0] == 'define':
		# define
		(_, name, value_exp) = exp
	    env[name] = evaluate(value_exp, env)
	    
	    
	   # ...
	   
każdy elif sprawdza pierwszy element z listy, następnie rozpakowuje listę, ignorując pierwszy element.


przykład 2-12
dopasowywanie wzorców z match/case - Python 3.10

def evaluate(exp: Expression, env: Environment) -> Any:
	"Evaluate an expression in an environment." 
	
	match exp:
		# ...
		case ['quote', x]:
			# dopasuj, jeśli temat jest dwuelementową sekwencją 
			# rozpoczynającą się od 'quote'
			return x
		
		case ['if', test, consequence, alternative]:
			# dopasuj jeśli temat jest czteroelementową sekwencją zaczynającą się od 'if'
			if evaluate(test, env):
				return evaluate(consequence, env)
			else:
				return evaluate(consequence, alternative)
		
		case ['lambda', [*parms], *body] if body:
			# dopasuj jeślitemat jest sekwencją trzech lub więcej elementów, 
			# zaczynającą się od 'lambda'. strażnik gwarantuje, że body nie jest puste
			# [*parms] - zagnieżdżona sekwencja
			return Procedure(parms, body, env)
			
		case ['define' Symbol() as name, value_exp]:
			# dopasuj, jeśli temat jest sekwencją trzyelementową rozpoczynającą się od 
			# 'define' po którym następuje wystąpienie klasy Symbol
			env[name] = evaluate(value_exp, env)
			
		case _:
			# przechwyć wszystko, 
			# jeśli exp nie pasuje do żadnego ze wzorców - można potraktować jako zdeformowane
			# dlatego zgłaszamy wyjątek SyntaxError
			raise SyntaxError(lispstr(exp))
			
bez klauzuli przechwytującej wszystko instrukcja match nie zrobi nic, gdy temat nie dopasuje żadnego przypadku - to może być bezgłośna awaria.

w przykładzie 2-11 we wzorcu 'define' kod nie sprawdza, czy name jest wystąpieniem klasy Symbol - powinno być wywołanie bloku if, wywołania isinstance

do przemyślenia
alternatywne wzorce dla lambda
--> 47 (78)

składnia skrótowa dla definiowania funkcji

	case ['define', [Symbol() as name, *parms], *body] if body:
		env[name] = Procedure(parms, body, env)


dopasowywanie wzorców jest przykładem programowania deklaratywnego:
kod opisuje, "co" chcemy dopasować, zamiast pokazywać "jak" to dopasować



info
https://norvig.com/lispy.html


wycinanie

wspólną funkcjonalnością typów list, tuple, str i wszystkich typów sekwencyjnych w Pythonie jest obsługa operacji wycinania

dlaczego wycinki i zakresy wykluczają ostatni wskazany element

Pythoniczna konwencja wykluczania ostatniego elementu w wycinkach i zakresach działa z indeksowaniem rozpoczynającym się od zera używanym w Pythonie, C i wielu innych językach

- długość wycinka lub zakresu można zobaczyć, gdy podana jest tylko pozycja końcowa:
zarówno range(3), jak i my_list[:3] wytwarzają trzy elementy 

- obliczenie długości wycinka lub zakresu, gdy podane są pozycje początkowa i końcowa:
stop - start

- podzielenie sekwencji na dwie części w miejscu oznaczonym dowolnym indeksem x, bez nakładania (?):
my_list[:x] i my_list[x:]s 

przykład

>>> l = [10, 20, 30, 40, 50, 60]
podział na 2 pozycji
>>> l[:2]
[10, 20]
		
>>> l[2:]
[30, 40, 50, 60]


podział na 3 pozycji
>>> l[:3]
[10, 20, 30]

>>> l[3:]
[40, 50, 60]
>>> 

Obiekty wycinków

składnia wycinków s[a:b:c]
może służyć do określania kroku albo skoku c, co sprawia, że wynikowy wycinek pomija elementy.
Krok ujemny powoduje zwracanie elementów w odwrotnej kolejności

>>> s[::3]
'bye'
>>> s[::-1]
'elcycib'
>>> s[::-2]
'eccb'
>>> 

import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]


deck = FrenchDeck()

>>> class FrenchDeck:
...     ranks = [str(n) for n in range(2, 11)] + list('JQKA')
...     suits = 'spades diamonds clubs hearts'.split()
...     def __init__(self):
...             self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]
...     def __len__(self):
...             return len(self._cards)
...     def __getitem__(self, position):
...             return self._cards[position]

>>> deck = FrenchDeck()


przykład wycinka deck[12::13] użytego do pobrania wszystkich asó z niepotasowanej talii kart
 
>>> deck[12::13]
[Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'), 
Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')]
>>> 

notacja a:b:c jest prawidłowa tylko wewnątrz [] - kiedy używana jest jako operator indeksujący i wytwarza obiekty wycinków: slice(a, b, c)

wycinkom można przypisywać nazwy

przykład
potrzebujemy przetworzyć dane płaskiego pliku, jak w przykładzie 2-13

invoice = """
0.....6.................................40........52...55........
1909  Pimoroni PiBrella                     $17.50    3    $52.5
1489  6mm Tactile Switch x20                 $4.95    2     $9.9
1510  Panavise Jr. - PV-201                 $28.00    1    $28.
1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95
"""


SKU = slice(0, 6)
DESCRIPTION = slice(6, 40)
UNIT_PRICE = slice(40, 52)
QUANTITY = slice(52, 55)
ITEM_TOTAL = slice(55, None)

line_items = invoice.split('\n')[2:]


for item in line_items:
     print(item[UNIT_PRICE], item[DESCRIPTION])

    $17.50   Pimoroni PiBrella                 
     $4.95   6mm Tactile Switch x20            
    $28.00   Panavise Jr. - PV-201             
    $34.95   PiTFT Mini Kit 320x240  





Wycinanie wielowymiarowe i wielokropki

operator [] może przyjmować wielowymiarowe indeksylub wycinki rozdzielone przecinkami

metodyspecjalne __getitem__ i __setitem__, które obsługują operator [], odbierają indeksy w a[i, j]
jako krotkę - aby odczytać a[i, j], Python wywołuje a.__getitem__((i, j))

używane jest to w zewnętrznym pakiecie NumPy, gdzie elementy dwuwymiarowej tablicy numpy.narray mogą być przechwytywane przy użyciu składni a[i, j], a dwuwymiarowy wycinek pozyskany za pomocą takiego wyrażenia jak a[m:n, k:l]

Wbudowane typy sekwencji w Pythonie są jednowymiarowe, wiec mogą obsługiwać tylko jeden indeks lub wycinek, a nie ich krotkę

wielokropek - ... - jest rozpoznawany przez parser Pythona jako token.
jest aliasem do obiektu Ellipsis, pojedynczej instancji klasy ellipsis
Może być przekazywany jako argument do funkcji oraz jako część specyfikacji wycina, 
jak w f(a, ..., z) lub a[i, ...]

w module NumPy wielokropek ... jest używany jako skrót podczas wycinni tablic o wielu wymiarach.
jeśli np. x to tablica czterowmiarowa, x[i, ...] jest skrótem dla x[i, :, :, :,]

https://numpy.org/doc/stable/user/quickstart.html#indexing-slicing-and-iterating


ciekawe jakie są zastosowania Ellipsis?

wycinki nie są jedynie przydatne do wyodrębniania informacji z sekwencji.

można ich używać do modyfikacji zmiennych sekwencji w miejscu - czyli bez budowania ich od początku.

Przypisywanie do wycinków

można wszczepiać lub usuwać fragmenty sekwencji zmiennychlub w inny sposób modyfikowaćje w miejscu przy użyciu notacji wycinka po lewej stronie polecenia przypisania lub jako celu polecenia del (usuwanie).


przykład

>>> l = list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> 

>>> l[2:5]
[2, 3, 4]

>>> l[2:5] = [20, 30]
>>> l
[0, 1, 20, 30, 5, 6, 7, 8, 9]
>>> 

>>> l[5:7]
[6, 7]

>>> del l[5:7]
>>> l
[0, 1, 20, 30, 5, 8, 9]


>>> l[3::2]
[30, 8]

>>> l[3::2] = [11, 22]
>>> l
[0, 1, 20, 11, 5, 22, 9]

kiedy cel przypisania jest wycinkiem -> l[2:5] to po prawej stronie musi być obiekt iterowalny, nawet wtedy gdy ma tylko 1 element

>>> l[2:5] = 100
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only assign an iterable
>>> 

>>> l[2:5] = [100]
>>> l
[0, 1, 100, 22, 9]
>>> 

 
 str 51 (82)
