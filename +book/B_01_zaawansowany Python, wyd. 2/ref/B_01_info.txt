B_01_info

1. Model danych
str 3 (34)

pythoniczność

przykład:
zamiast collection.len() stosuje się len(collection)

idiomatyczne funkcjonalności języka

formalizacja interfejsu bloków konstrukcyjych

str 5 (36)

------------------------------------
przykład P_1-1
------------------------------------

klasa FrenchDeck niejawnie dziedziczy z klasy obiekt, jej funkcjonalność nie jest dziedziczona,ale pochodzi z podległeo modelu danych i kompozycji. Dzięki implementacji metod specjalnych __len__ i __getitem__, klasa FrenchDeck zachowuje się jak standardowa sekwencja Pythona, pozwalając na korzystanie  z podstawowych funkcjonalności języka (np. iteracji i wycinania) oraz biblioteki standardowej, przykładem może być użycie funkcji random.choice, reversed i sorted
dzięki kompozycji implementacje metod __len__ i __getitem__ mogą delegowaćcałą pracę do obiektu list o nazwie self._cards


w aktualnej implenetacji talii FrenchDeck nie da się tasować - bo niezmienna: karty i ich pozycje nie mogą być zmieniane bez naruszenia hermetyzacjii bezpośredniej obsługi atrybutu _cards 
tasowanie - kiedyś tam! r 13

ważną cechą metod specjaln jest to że mają być wywoływane przez interpreter Pythona, a nie przez programistę.
nie piszemy my_object.__len__()
a piszemy len(my_object) -> gdy my_object jest wystąpieniem klasy zdefiniowanej przez użytkownika -> to Python wywoła zaimplementowaną metodę __len__

interpreter używa skrótu dla typów wbudowanych, takich jak list, str, bytearray lub rozszerzeń - takich jak tablice NumPy.

Kolekcje Pythona o zmiennym rozmiarze napisane są w C zawierają strukturę o nazwie PyVarObject, która zawiera pole ob_size - co jest znacznie szybsze od wywołania metody.

Najczęściej wywoływanie metod specjalnych odbywa się niejawnie.
dla przykładu: instrukcja for i in x: powoduje wywołanie funkcji iter(x), która z kolei może wywołac metodę x.__iter__(), jeśli jest ona dostępna, albo użyć x.__getitem__() - jak w przykładzie FrenchDeck

zwykle kod nie powinien zawierać zbyt wielu bezpośrednich wywołańmetod specjalnych.
o ile nie zajmujemy się metaprogramowaniem, powinnyśmy znacznie częściej implementować metody specjalne, niż wywoływać jest w sposób jawny.

Jedyną metodą specjalną która jest często wywoływana bezpośrednio w kodzie użytkownika jest metoda __init__.
służy ona do wywołania inicjatora klasy nadrzędnej we własnej implementacji metody __init__


jeśli potrzebujemywywołac metodę specjalną, zwykle lepiej jest wywołać związaną z nią funkcję wbudowaną (np. len, iter, str)
te wbudowane funkcję wywoują odpowiednią metodę specjalną, ale często dostarczają także inne usługi, poza tym w przypadku typów wbudowanych sa szybsze od wywołań metod


emulowanie typów numerycznych
reprezentacja tekstowa obiektów
wartość logiczna obiektów
implementowanie kolekcji



emulacja typów liczbowych

implementujemy klasę reprezentującą wektory dwuwymiarowe -> wektory euklidesowe

do replezentacji wektorów dwuwymiarowych wystarałby typ complex - lecz naszą klasę chcemy poszerzyć aby reprezentowała wektory n-wymiarowe

projekt interfejsu API dla klasy
symulowana wersja sesji konsoli

v1 = Vector(2, 4)
v2 = Vector(2, 1)
v1 + v2
Vector(4, 5)

operator + tworzy wynik w postaci Vector i wyświetlany jest w postaci Vector(4, 5)

wbudowana funkcja abs zwraca wartość bezwzględną liczb całkowitychi zmiennoprzecinkowych
orz moduł liczb zespolonych- complex

aby zachować spójność w API również użyjemy funkcji abs do obliczenia modułu wektora:

v = Vector(3, 4)
abs(v)
5.0


implementacja operatora * - mnożenie przez skalar (tj. przez liczbę)

v * 3
Vector(9, 12)
abs(v * 3)
15.0

przykłąd 1-2 klasa Vector która ma zaimplementowane operacje dzięki użyciu metod specjalnych __repr__, __abs__, __add__ i __mul__

------------------------------------
przykład P_1-2
------------------------------------

żadna z zaimplementowanych metod nie jest bezpośrednio wywoływana wewnątrz klasy
są one wywoływane przez interpreter Pythona

w przykładzie mamy zaimplementowa operatory + oraz * - co pokazuje podstawowe użycie metod __add__ oraz __mul__
w obu przypadka metody zwracają nową instancję klasy Vector i niemodyfikują żadnego operandu - self i other są jedynie odczytywane.
jest to oczekiwane zachowanie operatorów infiksowych -> tworzą nowe obiekty, nie modyfikują operandów


reprezentacja tekstowa

metoda specjalna __repr__ jest wywoływana przez wbudowaną funkcję repr, aby otrzymać reprezentację tekstową obiektu do inspekcji.

jeśli metoda __repr__ nie będzie zaimplementowana, wystąpienia wektorów byłyby pokazana w konsoli w taki sposób

<Vector object at 0x10f5a0c10>

konsola oraz debugger wywołują funkcje repr na wynikach przetważanych wyrażeń, taj jak to robi symbol zastępczy %r w klasycznym formtowaniu z operatorem % i pole konwersji !r w nowej składn formatowania

https://docs.python.org/3.10/library/string.html#format-string-syntax
Format String Syntax

używanej przez f-strings w metodzie str.format


użyte f-string w naszej implementacji __repr__ używa !r

return f'Vector({self.x!r}, {self.y!r})'

do otrzymania standardowejreprezentacji atrybutówdo wyświetlenia.
jest istotna różnica w pokazywaniu Vector(1, 2) a Vector('1', '2') - oczywiście drugi przypadek nie działałby gdyż argumentami onstruktora muszą być liczby, a nie łańcuchy

Łańcuch znaków zwracany przez __repr__ powinien być jednoznacznyi o ile możliwe odpowiadać kodowi źródłowemu koniecznemu do ponownego utworzenia reprezentowanego obiektu

w naszym przykładzie wybrana reprezentacja wygląda tak jak wywołnie konstruktora klasy
np. Vector(3, 4)

metoda __str__ jest wywoływana przez wbudowną funkcję str() i niejawnie używan w funkcji print()

metoda __str__ powinna zwracać łańcuch odpowiedni do wyświtlenia dla użytkowników końcowych.

 w przypadku implementacji tylko jednej z tych metod specjalnych (___str__, __repr__) korzystniej wybrać __repr__, gdyż nie ma dostępnej niestandardowej metody __str__.
 Python wywoła __repr__ jako metoę rezerwową
 
 
 What is the difference between __str__ and __repr__?
 https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr
 
 
 
 
 Wartość logiczna trybu niestandardowego
 
 typ wbudowany w Pythonie to bool, lecz jest akceptowany dowolny obiekt w kontekstach logicznych, takich ja 
 wyrażenia kontrolujące instrukcje - if, while, operandy operatorów and, or i not.
 
 aby wyznaczy czy wartość x jest truthy czy falsy, Python stosuje bool(x), co zawsze zwraca True lub False.
 
 Domyślne wystąpienia klas definiowanych przez użytkownika są uważana jako truthy, o ile nie mają zaimplementowanych metod __bool__ ani __len__
 
 zasadzniczo bool(x) wywołuje x.__bool__i wykorzystuje wynik tej metody.
 jeś metoda __bool__ nie jest zaimplementowana Python próbuje wywołać metodę x.__len__(), a jeśli ona zwraca zero, to bool zwraca False, w przeciwnym razie boo zwraca True.
 
 w naszym przykładzie implementacja metody __bool__jest koncepcyjnie prosta - zwraca False gdy moduł wektora jest równy zero, a w przeciwnym wypadku True.
 
 konwertujemy moduł na Boolean przy użyciu bool(abs(self)) - ponieważ metoda __bool__ ma zwracać zgodnie z oczekiwaniem typ logiczny.
 
poza metodą __bool__ rzadko zdarza się konieczność jawnego wywołania bool(), gdyż każdego obiektunayć w kontekscie logicznym.

można zauważyć że specjalna metoda __bool__ pozwala obiektom na spójność z regułami testowania wartości prawdy które są zdefiniowane w dokumentacji Pythona -

Truth Value Testing
https://docs.python.org/3/library/stdtypes.html#truth

można też wykreować szybszą implementację Vector.__bool__

def __bool__(self):
	return bool(self.x or self.y)
	

API kolekcji

interfejs podstawowych typów kolekcji występujących w języku
wszystkie klasy to ABC - abstrakcyjne klasy bazowe.

każda z najwyższych klas ABC zawiera pojedynczą metodę specjalną.
klasa ABC Collection - od Pythona 3.6 - unifikuje trzy kluczowe interfejsy, które powinna implementować każda kloekcja 

- Iterable - obsługa for, rozpakowywania* i innych form iteracji

	     * 4.8.5. Unpacking Argument Lists
	       https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists

- Sized - wsparcie wbudownej funkcji len
- Container - obsługa operatora in

Python nie wymaga od konkretnych klas, aby rzeczywiście wywodziły się z której kolwiekz tych klas ABC

Dowolna klasa implementująca __len__ spełnia wymagania interfejsu Sized

Ważne specjalizacje Collection:

Sequence - formalizuje interfejs wbudowanych funkcji, takich jak list i str
Mapping - implementowane przez dict, collections.deaultdict itp
Set - interfejs typów wbudowanych set i frozenset

tylko klasa Sequence jest Reversible - gdyż sekwencje wspierają dowolne porządkowanie swojej zawartości- czego nie obsługują odwzorowania ani zbiory

począwszy od Pythona 3.7 dict jest oficjalnie uporządkowany - tzn. zachowana jest kolejność wstawiania kluczy - nie można zmienić kolejności kluczy w dict wg własnego życzenia

przegląd metod specjalnych

Data model
https://docs.python.org/3/reference/datamodel.html

2. Tablica sekwencji

Python odziedziczył z ABC (językiem ABC) ujednoliconą obsługę sekwencji

Łańcuchy, listy, sekwencje bajtów, tablice, elementy XML i wyniki baz danych współdzielą bogaty zbiór operacji, obejmujący iteracje, wycinanie, sortowanie i łączenie 

zrozumienie list oraz podstawy wyrażeń generatorów
używanie krotek jako rekordów kontra ich wykorzystywanie jako niezmiennych list
rozpakowywanie sekwencji i wzorce sekwencji
czytanie i zapisywanie wycinków
specjalizowane typy sekwencji, jak tablice i kolejki


zarządzanie uporządkowanymi sekwencjami za pomocą bisect
https://www.fluentpython.com/extra/ordered-sequences-with-bisect/

przegląd wbudowanych sekwencji

biblioteka standardowa oferuje wiele typów sekwencji zaimplementowanych w języku C:

Sekwencje kontenerowe - przechowują elementy różnych typów, włącznie z innymi kontenerami
np. list tuple i collections.deque

Sekwencje płaskie - przechowują elementy jednego typu
np. str, bytes i array.array

Sekwencje kontenerowe - przechowują odwołania do zawartych w sobie obiektów, które mogą być dowolnego typu

sekwencje płaskie są bardziej upakowane, lec przy tym ograniczone do przechowywania prymitywnych wartości - takich jak znaki, bajty i liczby

każdy obiekt Pythona w pamięcia zawiera nagłówek z metadanymi
najprostszy obiekt Pythona - float, ma pole wartości oraz dwa pola metadanych:
ob_refcnt - licznik referencji do obiektu
ob_type - wskaźnik do typu obiektu
ob_fval - liczba double języka C, przechowywująca wartość

https://docs.python.org/3/c-api/typeobj.html#slot-type-typedefs

w 64-bitowe kompilacji Pythona każde z tych pól zajmuje 8 bajtów.

tablica float jest bardziej zwarta, niż krotka z tymi samymi wartościami.
tablica to pojedynczy obiekt przechowywujący surowe wartośc, podcas gdy krotka składa się z wielu obiektów - siebie samej oraz każdego obiektu float w niej zawartego


innym sposobem grupowania sekwencji jest ich zmienność

Sekwencje zmienne
list byte.array, array.array, i collections.deque

Sekwencje niezmienne
tuple, str i bytes



Wyrażenia listowe i wyrażenia generatora
szybkim sposobem na zbudowanie sekwencji jest użycie wyrażenia listowego - gdy celem jest list - lub wyrażenia generatora - dla wszystkich innych rodzajów sekwencji.

nie używając tych form syntaktycznych - nasz kod jest mniej czytelny, również mniej szybszy

w środowisku Pythona
wyrażenia listowe - to listcomp
wyrażenia generatora - to genexp

Przykład 2-1

Przykład 2-2

bardziej czytelny przykładem jest przykład 2-2


zastosowanie pętli for
do skanowania sekwencji, aby zliczać lub wybierać elementy
obliczanie agregacji - sum, średnich
przetwarzanie

kod 2-1 buduje listę
w 2-2 jest zastosowane wyrażenie listowe - jego zadaniem jest budowanie listy

w przypadku stosowania wyrażeń listowych, należy brać pod uwagę aby to wyrażenie nie miało więcej niż dwa wiersze i było zwięzłe


w kodzie Pythona podziały wierszy są ignorowane wewnątrz parnawiasów []{} lub ()
jest możliwe budowanie wielowierszowych list, wyrażeń listowych i generatorów, słowników itp. bez używania znaku ucieczki \ do oznaczania kontynuacji wiersza.
stosując \ nie wolno umieścić po nim żadnego znaku - nawet spacji

kodując wielowierszowy literał listowy należ zadbać aby po ostatniej pozycji umieścić przecinek -
aby nie tworzyć zamętu przy wyszukiwaniu różnic


---------------------------------------------------
Lokalny zasięg w wyrżeniach listowych i generatora

w Pytchonie 3 wyrażenia listowe, wyrażenia generatora, wyrażenia zbiorów - setcomp - oraz słownikowe - dictcomp, mają zasięg lokalnydo przechowywania zmiennych przypisanych w klauzuli for

zmienne przypisane za pomocą 'operatora morsa' := pozostają dostępne po powrocie z tych wyrażeń - w przeciwieństwie do lokalnych zmiennych funkcji

PEP 572 – Assignment Expressions
https://peps.python.org/pep-0572/

przykład 1

x = 'ABC'
codes = [ord(x) for x in x]
x
'ABC'
codes
[65, 66, 67]

x - jest powiązany z 'ABC' - nie jest oderwany

przykład 2

codes = [last := ord(c) for c in x]
last
67
c
Traceback (most recent call last):
  File "/snap/pycharm-community/323/plugins/python-ce/helpers/pydev/pydevconsole.py", line 364, in runcode
    coro = func()
  File "<input>", line 1, in <module>
NameError: name 'c' is not defined

last jest widoczne poza zakresem
c - nie jest widoczne poza zakresem

---------------------------------------------------

wyrażenia listowe budują listy na podstawie sekwencji lub dowolnego innego typu iterowalnego za pomocą filtrowania i transformcji elementów.
to samo można realizować za moca wbudowanych funkcji filter i map


Wyrażenia listowe a funkcje filter i map

Przykład 2-3
budowanie listy  za pomocą wyrażenia listowego i złożenia funkcji map-filter

>>> symbols = '$¢£¥€¤'
>>> beyond_ascii = [ord(s) for s in symbols if ord(s) > 127]
>>> beyond_ascii
[162, 163, 165, 8364, 164]



>>> beyond_ascii = list(filter(lambda c: c > 127, map(ord, symbols)))
>>> beyond_ascii
[162, 163, 165, 8364, 164]



test szybkości 
https://github.com/fluentpython/example-code-2e/blob/master/02-array-seq/listcomp_speed.py

Iloczyny kartezjańskie
wyrażenia listowe mogą generować listy na podstawie iloczynu kartezjańskiego dwóch obiektów iterowalnych lub większej ich liczby.

elementy składające się na iloczyn kartezjański to krotki powstałe z elementów pochodzących z każdego wejściowego obiektu iterowalnego.

wynikowa lista ma długość równą przemnożonym długością wejściowych obiektów iterowalnych

iloczyn kartezjański sekwencji trzech wartości kart i sekwencji czterech kolorów, w wyniku daje sekwencję dwanastu par

 
przykład iloczynu kartezjańskiego z zastosowaniem wyrżeni listowego

>>> colors = ['black', 'white']
>>> sizes = ['S', 'M', 'L']
>>> tshirts = [(color, size) for color in colors for size in sizes]
generuje listę krotek uporządkowanych wg koloru - color, a następnie rozmiaru - size
>>> tshirts
[('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), ('white', 'M'), ('white', 'L')]

taka lista jest porządkowana tak, jakby pętle for były zagnieżdżone w tej samej kolejności, w jakiej występują w wyrażeniu listowym

>>> for color in colors:
...     for size in sizes:
...             print((color, size))
... 
('black', 'S')
('black', 'M')
('black', 'L')
('white', 'S')
('white', 'M')
('white', 'L')

aby uporządkować elementy wg rozmiaru, a następnie koloru, należy zmienić kolejność klauzul for.
zmiana sposobu zapisu wyrażenia listowego poprawia czytelność wyrażenia

>>> tshirts = [(color, size) for size in sizes
...                          for color in colors]
>>> tshirts
[('black', 'S'), ('white', 'S'), ('black', 'M'), ('white', 'M'), ('black', 'L'), ('white', 'L')]


w przykładzie 1-1
    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]
        
dla poprawienia czytelności = można ją zapisać:

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits 
        				for rank in self.ranks]
        				

wyrażenia listowe mają tylko jedno zastosowanie: budują listy
        

wyrażenia generatora

do inicjalizacji krotek, tablic i innych typów sekwencji możemy początkowo używać także wyrażeń listowych , lecz wyrażenia generatora oszczędzają pamięć - generują pojedyncze elementy przy użyciu protokołu iteratora, zamiast budować całą listę  tylko po to, by załadować ją do innego konstruktora

wyrażenia generatora korzystają z tej samej składni co wyrażenia listowe, ale są zawarte w nawiasach okągłych  a nie kwadratowych

podstawowe użycie wyrażeń generatora do budowania krotki i tablicy

inicjowanie krotki i tablicy za pomocą wyrażenia generatora

>>> symbols = '$¢£¥€¤'
>>> tuple(ord(symbol) for symbol in symbols)
(36, 162, 163, 165, 8364, 164)

jeśli wyrażenie generatora stanowi pojedynczy argument w wywołaniu funkcji, nie ma potrzeby dublowania nawiasów otaczających

>>> import array
>>> array.array('I', (ord(symbol) for symbol in symbols))
array('I', [36, 162, 163, 165, 8364, 164])

konstruktor array przyjmuje dwa argumenty, więc nawiasy wokół wyrażenia generatora są obowiązkowe.

pierwszy argument konstruktora array definiuje typ służący do przechowywania liczb w tablicy.

Przykład 2-6
Iloczyn kartezjański w wyrażeniu generatora
 
>>> colors = ['black', 'white']
>>> sizes = ['S', 'M', 'L']
>>> for tshirt in ('%s %s' % (c, s) for c in colors for s in sizes):
...     print(tshirt)
... 
black S
black M
black L
white S
white M
white L

wyrażenie generatora wytwarza elementy pojedynczo.
w tym przykładzie lista sześciu odmian koszulek nie powstaje


Krotki
krotki mogą służyć jako niezmienne listy, ale także jako rekordy bez nazw pól.

Krotki jako rekordy

krotki przechowuj rekordy - każdy element w krotce przechowuje dane jednego pola, a położenie tego elementu wyznacza jego znaczenie.

jeśli krotki mają być uważane jako niezmienne listy - to nalezy uważać, że liczba i kolejność elementów w zależności od kontekstu może, ale nie musi być istotna.

jeśli krotki używamy jako kolekcji pól, liczba elementów jest często stała, a ich kolejność zawsze ważna.

przykład 2-7
zastosowanie krotki jako rekordy

>>> lax_coordinates = (33.9425, -118.408056)
szerokość i długość geograficzna lotniska międzynarodowego w Los Angeles

city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)
dane dotyczące Tokyo: nazwa, rok, populacja (w mln), zmiana populacji (%), obszar (km2)

>>> traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205856')]
lista krotek zawierających kod krajui numer paszportu w formie (country_code, passport_numbeer)


>>> for passport in sorted(traveler_ids):
...     print('%s/%s' % passport)
... 
BRA/CE342567
ESP/XDA205856
USA/31195855

podczas iteracji zmienna passport wiązana jest z poszczególnym krotkami

'%s/%s' % passport - operator formatujący % rozumie krotkii traktuje każdy element jako oddzielne pole

>>> for country, _ in traveler_ids:
...     print(country)
... 
USA
BRA
ESP

pętla for wie jak oddzielnie pobierać elementy z krotek - jest to nazywane rozpakowywaniem 
w tym przykładzie drugi element jest nie istotny - wobec tego jest przypisany do zmiennej fikcyjnej

często uważa się rekordy jako struktury danych z nazywanymi polami.
w ww przykładzie mamy taką strukturę:

city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)

jest to przykład rozpakowywania krotek



krotki jako niezmienne listy

interpreter Pythona oraz biblioteka standardowa szeroko wykorzystują krotki jako niezmienne listy 

korzyści:

przejrzystość - w kodzie długość krotki się nigdy nie zmien

wydajność - krotka zajmuje mniej pamięci, niż lista o tej samej długości - co pozwala Pythonowi dokonać pewnych optymalizacji

niezmienność krotki dotyczy tylko referencji, które zawiera.

zawartość krotki jako takiej jest niezmienna, oznacza to, że przechowywane w niej referencje zawsze będą wskazywać te same obiekty.
jeśli jeden ze wskazywanych obiektów jest zmienny - np. lista - jego zawartość może sie zmienić.

>>> a = (10, 'alpha', [1, 2])
>>> b = (10, 'alpha', [1, 2])
>>> a == b
True
>>> b[-1].append(99)
>>> b
(10, 'alpha', [1, 2, 99])
>>> a == b
False


jak określić jawnie, czy krotka (lub dowolny inny obiekt) ma ustaloną wartość, można użyć wbudowanej funkcji hash 
obiekt jest hashowalny jedynie wtedy gdy jego wartość nigdy nie może sie zmienić.
niehashowalnej krotki nie można wstawić jako kluca do słownika - dict ani elementu zbioru - set

przykład funkcji która jawnie okresla czy krotka (lub dowolny inny obiekt) ma ustaloną wartość, używając wbudowanej funkcji hash()

>>> def fixed(o):
...     try:
...             hash(o)
...     except TypeError:
...             return False
...     return True
... 
>>> tf = (10, 'alpha', (1, 2))
>>> tm = (10, 'alpha', [1, 2])
>>> fixed(tf)
True
>>> fixed(tm)
False

w pewnym sensie jest to pułapka - nie wychwycenie - czy krotka jest ze zmiennymi elementami 

-->
https://stackoverflow.com/questions/68630/are-tuples-more-efficient-than-lists-in-python/22140115#22140115

Are tuples more efficient than lists in Python?
Czy w Pythonie krotki są wydajniejsze od list?

przy przetworzeniu literału krotki, Python generuje kod bajtowy dla stałej krotkowej w jednej operacji
dla literału listy kod bajtowy wypycha każdy element jako oddzielną stałą na stos danych, po czym buduje listę.

dla danej krotki t zwraca referencję do samego t.
nie ma potrzeby kopiowania 
dla listy l konstruktor list(l) musi utworzyć nową kopię l.

dzięki określoej długości instancja krotki ma alokowane dokładnie tyle pamięci, ile potrzebuje

referencje do elementów w krotce przechowywane są w tablicy w strukturze krotki.
lista utrzymuje wskaźnik do tablicy referencji przechowywanej w innym miejscu.
jest to istotne gdyż lista rozrastając się ponad wielkość aktualnie alokowanej przestrzeni, Python musi realokowoać tablicę referencji, aby zrobić miejsce.
takie podejście sprawia, że pamieć podręczna procesora jest mniej efektywna.


porównanie metod krotek i list

krotki obsługują wszytkie metody list, które nie obejmują dodawania ani usuwania elementów, krotki nie mają metody __reversed__ lecz działa na nie funkcja reversed(krotka)



rozpakowywanie sekwencji i typów iterowalnych

rozpakowywanie pozwala uniknąć niepotrzebnego i podatnego na błędy używania indeksów w celu wydobywanie=a elementów z sekwencji

rozpakowywanie działa z dowolnym iterowalnym obiektem jako źródłem danych - wyłącznie z iteratorami, które nie obsługują notacji indexowej ([])

jedynym wymogiem jest to, że typ iterowalny zwraca dokładnie jeden element na zwienną po stronie odbierającej, o ile nie zostanie użyta gwiazdka (*) do przechwycenia nadmiarowych elementów

najbardziej widoczna forma rozpakowywania to przypisywanie równoległe - przypisywanie elementów typu iterowalnego do krotki zmiennych

>>> lax_coordinates = (33.9425, -118.408056)
>>> latitude, longitude = lax_coordinates
>>> latitude
33.9425
>>> longitude
-118.408056
>>> 

zastosowanie rozpakowywania poprzez zamianę wartości zmiennych  bez użycia zmiennej tymczasowej

>>> b, a = a, b

rozpakowywanie jest poprzedzone argumentu gwiazdką (*) przy wywołaniu funkcji

>>> divmod(20, 8)
(2, 4)
>>> t = (20, 8)
>>> divmod(*t)
(2, 4)
>>> quotient, remainder = divmod(*t)
>>> quotient, remainder
(2, 4)
>>> 

funkcja zwraca wiele wartości w sposób wygodny dla wywołującego.

przykładem może być funkcja os.path.split() - buduje ona krotkę (path, last_part) ze ścieżki systemu plików:


>>> import os
>>> _, filename = os.path.split('/home/luciano/.ssh/id_rsa.pub')
>>> filename
'id_rsa.pub'
>>> 

używanie * do przechwytywania nadmiarowych elementów

definiowanie parametrów funkcji przy użyciu *args w celu przechwyceni dowolnych nadmiarowych argumentów jest klasyczną cechą Pythona.

w Pythonie 3 idea została rozszerzona również na przypisanie równoegłe

>>> a, b, *rest = range(5)
>>> a, b, rest
(0, 1, [2, 3, 4])
>>> 
>>> a, b, *rest = range(3)
>>> a, b, rest
(0, 1, [2])
>>> 
>>> a, b, *rest = range(2)
>>> a, b, rest
(0, 1, [])


prefix * może być zastosowany do dokoładnie jednej zmiennej, ale może się pojawić na dowolnej pozycji

>>> a, *body, c, d = range(5)
>>> a, body, c, d
(0, [1, 2], 3, 4)
>>> 
>>> *head, b, c, d = range(5)
>>> head, b, c, d
([0, 1], 2, 3, 4)

rozpakowywanie z * w wywołaniach funkcjii literałach sekwencji

https://peps.python.org/pep-0448/
wprowadzona bardziej elastyczną składnię dla rozpakowania iterowalnych

https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations

w wywołaniach funkcji możemy użyć * wiele razy:

>>> def fun(a, b, c, d, *rest):
...     return a, b, c, d, rest
... 
>>> fun(*[1, 2], 3, *range(4, 7))
(1, 2, 3, 4, (5, 6))

Gwiazdka * może również zostać być użyta przy definiowania literałówlist, tupli lub set:

>>> *range(4), 4
(0, 1, 2, 3, 4)
>>> 

>>> [*range(4), 4]
[0, 1, 2, 3, 4]
>>> 

>>> {*range(4), 4, *(5, 6, 7)}
{0, 1, 2, 3, 4, 5, 6, 7}
>>> 

rozpakowywanie krotek działa również z zagnieżdżonymi strukturami.



Zagnieżdżone rozpakowywanie


Rozpakowywanie zagnieżdżonych krotek w celu dostępu do długości geograficznej:

Przykład 2-8
każda krotka przechowuje rekord z czterema polami, przy czym ostatnie pole to para współrzędnych
 ('Tokyo', 'JP', 36.933, (35.689722, 139.691667))

poprzez przypisanie ostatniego pola do zagnieżdżonej krotki rozpakowujemy współrządne
for name, _, _, (lat, lon) in metro_areas: 
	...

test lon <= 0: wybiera jedynie miasta z zachodniej półkuli
if lon <= 0: 
	...

>>> metro_areas = [
...     ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),
...     ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
...     ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
...     ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
...     ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)),
... ]
>>> def main():
...     print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')
...     for name, _, _, (lat, lon) in metro_areas: 
...             if lon <= 0: 
...                     print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')
... 

>>> main()

                |  latitude | longitude
Mexico City     |   19.4333 |  -99.1333
New York-Newark |   40.8086 |  -74.0204
São Paulo       |  -23.5478 |  -46.6358


obiektem docelowym przypisania rozpakowywującego może być lista
mogą to być zapytania bazodanowe zwracający pojedynczy rekord - np. kod SQL zawierający klauzulę LIMIT 1
[record] = query_returning_single_row()
po zapisaniu w wykorzystaniem krotek - byłby zapis (record,)

gdy rekord zawiera tylko jedno pole, możemy je otrzymać bezpośrednio:
[[field]] = query_returning_single_row_with_single _field()
po zapisaniu z wykorzystaniem krotek - ((field,),)

w obu przypadkach istotny jest przecinek


Dopasowanie wzorców w sekwencjach

nową funkcjonalnością Pythona 3.10 jest dopasowywanie wzorców oparte na instrukcji match/case

PEP 634 – Structural Pattern Matching: Specification
Strukturalne dopasowywanie wzorców

https://peps.python.org/pep-0634/

https://docs.python.org/3.10/whatsnew/3.10.html#pep-634-structural-pattern-matching
https://docs.python.org/3.10/whatsnew/3.10.html


Przykład 2-9
przykład użycia match/case
- metoda z fikcyjnej klasy robot

match message: -> wyrażenie po słowie kluczowym match to temat(subject) - są to dane, które Python będzie próbował dopasować do wzorców w każdej klauzuli case

def handle_command(self, message):
	match message:
		case ['BEEPER', frequency, times]:
		# **1
			self.beep(times, frequency)
			
		case ['NECK', angle]:
		# **2
			self.rotate_neck(angle)
			
		case ['LED', ident, intensity]:
		# **3
			self.leds[ident].set_brightness(ident, intensity)
		
		case ['LED', ident, red, green, blue]:
		# **4
			self.leds[ident].set_color(ident, red, green, blue)
		case _:
		# **5
			raise InvalidCommand(message)
			
**1
ten wzorzec pasuje do każdego tematu, który jest sekwencją trzech elementów
- 'BEEPER'
- kolejne dwa mogą być czymkolwiek i zostaą przypisane do zmiennych frequency oraz times

**2
dopasowanie do dowolnego tematu z dwoma elementami, z których pierwszym jest 'NECK'

**3
to pasuje do tematu z trzema elementami zaczynającymi się od 'LED'
jeśli liczba elementów nie pasuje, Python przejdzie do nastęnej klauzuli case

**4 
kolejny wzorzec 'LED' z pięcioma elementami

**5
domyślny przypadek
zostanie dopasowany do dowolnego tematu, który nie został dopasowany wcześniej
zmienna _ jest specjalna.


jednym z kluczowych ulepszeń match/case jest destrukturyzacja - bardziej zaawansowana forma rozpakowywania - jest to nowość w Pythonie


Przykład 2-10
zmodyfikowano Przykład 2-8

>>> metro_areas = [
...     ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),
...     ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
...     ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
...     ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
...     ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)),
... ]
>>> def main():
...     print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')
...     for record in metro_areas: 
	       # tematem jest każda z krotek metro_areas
		
		match record: 
			case [name, _, _, (lat, lon)] if lon <= 0:
			     # klauzula case ma 2 części:
			     # wzorzec oraz opcjonalny strażnik 
			     # - zabezpieczenie po słowie kluczowym if
			     
...                          print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')
... 
>>> main()

wzorzecz [name, _, _, (lat, lon)] pasuje do sekwencji o czterech elementach - lecz ostatni element musi być sekwencją dwuelementową.

wzorce sekwencji mogą być krotka listami, dowolną kombinacją zagnieżdżonych krotek i list 
użycie nawiasów () lub [] we wzorcach zagnieżdżonych nie ma większego znaczenia mogą występować wymiennie

wzorzec sekwencji może pasować do wystąpień wiekszości rzeczywistych lub wirtualnych podklas collections.abc.Sequence, z wyjątkiem str, bytes i bytearray

wystąpienia str, bytes i bytearray nie są obsługiwane jako sekwencje w kontekście match/case










 str 42 (73)
