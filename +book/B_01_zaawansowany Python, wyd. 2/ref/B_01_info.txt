B_01_info

1. Model danych
str 3 (34)

pythoniczność

przykład:
zamiast collection.len() stosuje się len(collection)

idiomatyczne funkcjonalności języka

formalizacja interfejsu bloków konstrukcyjych

str 5 (36)

------------------------------------
przykład P_1-1
------------------------------------

klasa FrenchDeck niejawnie dziedziczy z klasy obiekt, jej funkcjonalność nie jest dziedziczona,ale pochodzi z podległeo modelu danych i kompozycji. Dzięki implementacji metod specjalnych __len__ i __getitem__, klasa FrenchDeck zachowuje się jak standardowa sekwencja Pythona, pozwalając na korzystanie  z podstawowych funkcjonalności języka (np. iteracji i wycinania) oraz biblioteki standardowej, przykładem może być użycie funkcji random.choice, reversed i sorted
dzięki kompozycji implementacje metod __len__ i __getitem__ mogą delegowaćcałą pracę do obiektu list o nazwie self._cards


w aktualnej implenetacji talii FrenchDeck nie da się tasować - bo niezmienna: karty i ich pozycje nie mogą być zmieniane bez naruszenia hermetyzacjii bezpośredniej obsługi atrybutu _cards 
tasowanie - kiedyś tam! r 13

ważną cechą metod specjaln jest to że mają być wywoływane przez interpreter Pythona, a nie przez programistę.
nie piszemy my_object.__len__()
a piszemy len(my_object) -> gdy my_object jest wystąpieniem klasy zdefiniowanej przez użytkownika -> to Python wywoła zaimplementowaną metodę __len__

interpreter używa skrótu dla typów wbudowanych, takich jak list, str, bytearray lub rozszerzeń - takich jak tablice NumPy.

Kolekcje Pythona o zmiennym rozmiarze napisane są w C zawierają strukturę o nazwie PyVarObject, która zawiera pole ob_size - co jest znacznie szybsze od wywołania metody.

Najczęściej wywoływanie metod specjalnych odbywa się niejawnie.
dla przykładu: instrukcja for i in x: powoduje wywołanie funkcji iter(x), która z kolei może wywołac metodę x.__iter__(), jeśli jest ona dostępna, albo użyć x.__getitem__() - jak w przykładzie FrenchDeck

zwykle kod nie powinien zawierać zbyt wielu bezpośrednich wywołańmetod specjalnych.
o ile nie zajmujemy się metaprogramowaniem, powinnyśmy znacznie częściej implementować metody specjalne, niż wywoływać jest w sposób jawny.

Jedyną metodą specjalną która jest często wywoływana bezpośrednio w kodzie użytkownika jest metoda __init__.
służy ona do wywołania inicjatora klasy nadrzędnej we własnej implementacji metody __init__


jeśli potrzebujemywywołac metodę specjalną, zwykle lepiej jest wywołać związaną z nią funkcję wbudowaną (np. len, iter, str)
te wbudowane funkcję wywoują odpowiednią metodę specjalną, ale często dostarczają także inne usługi, poza tym w przypadku typów wbudowanych sa szybsze od wywołań metod


emulowanie typów numerycznych
reprezentacja tekstowa obiektów
wartość logiczna obiektów
implementowanie kolekcji



emulacja typów liczbowych

implementujemy klasę reprezentującą wektory dwuwymiarowe -> wektory euklidesowe

do replezentacji wektorów dwuwymiarowych wystarałby typ complex - lecz naszą klasę chcemy poszerzyć aby reprezentowała wektory n-wymiarowe

projekt interfejsu API dla klasy
symulowana wersja sesji konsoli

v1 = Vector(2, 4)
v2 = Vector(2, 1)
v1 + v2
Vector(4, 5)

operator + tworzy wynik w postaci Vector i wyświetlany jest w postaci Vector(4, 5)

wbudowana funkcja abs zwraca wartość bezwzględną liczb całkowitychi zmiennoprzecinkowych
orz moduł liczb zespolonych- complex

aby zachować spójność w API również użyjemy funkcji abs do obliczenia modułu wektora:

v = Vector(3, 4)
abs(v)
5.0


implementacja operatora * - mnożenie przez skalar (tj. przez liczbę)

v * 3
Vector(9, 12)
abs(v * 3)
15.0

przykłąd 1-2 klasa Vector która ma zaimplementowane operacje dzięki użyciu metod specjalnych __repr__, __abs__, __add__ i __mul__

------------------------------------
przykład P_1-2
------------------------------------

żadna z zaimplementowanych metod nie jest bezpośrednio wywoływana wewnątrz klasy
są one wywoływane przez interpreter Pythona

w przykładzie mamy zaimplementowa operatory + oraz * - co pokazuje podstawowe użycie metod __add__ oraz __mul__
w obu przypadka metody zwracają nową instancję klasy Vector i niemodyfikują żadnego operandu - self i other są jedynie odczytywane.
jest to oczekiwane zachowanie operatorów infiksowych -> tworzą nowe obiekty, nie modyfikują operandów


reprezentacja tekstowa

metoda specjalna __repr__ jest wywoływana przez wbudowaną funkcję repr, aby otrzymać reprezentację tekstową obiektu do inspekcji.

jeśli metoda __repr__ nie będzie zaimplementowana, wystąpienia wektorów byłyby pokazana w konsoli w taki sposób

<Vector object at 0x10f5a0c10>

konsola oraz debugger wywołują funkcje repr na wynikach przetważanych wyrażeń, taj jak to robi symbol zastępczy %r w klasycznym formtowaniu z operatorem % i pole konwersji !r w nowej składn formatowania

https://docs.python.org/3.10/library/string.html#format-string-syntax
Format String Syntax

używanej przez f-strings w metodzie str.format


użyte f-string w naszej implementacji __repr__ używa !r

return f'Vector({self.x!r}, {self.y!r})'

do otrzymania standardowejreprezentacji atrybutówdo wyświetlenia.
jest istotna różnica w pokazywaniu Vector(1, 2) a Vector('1', '2') - oczywiście drugi przypadek nie działałby gdyż argumentami onstruktora muszą być liczby, a nie łańcuchy

Łańcuch znaków zwracany przez __repr__ powinien być jednoznacznyi o ile możliwe odpowiadać kodowi źródłowemu koniecznemu do ponownego utworzenia reprezentowanego obiektu

w naszym przykładzie wybrana reprezentacja wygląda tak jak wywołnie konstruktora klasy
np. Vector(3, 4)

metoda __str__ jest wywoływana przez wbudowną funkcję str() i niejawnie używan w funkcji print()

metoda __str__ powinna zwracać łańcuch odpowiedni do wyświtlenia dla użytkowników końcowych.

 w przypadku implementacji tylko jednej z tych metod specjalnych (___str__, __repr__) korzystniej wybrać __repr__, gdyż nie ma dostępnej niestandardowej metody __str__.
 Python wywoła __repr__ jako metoę rezerwową
 
 
 What is the difference between __str__ and __repr__?
 https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr
 
 
 
 
 Wartość logiczna trybu niestandardowego
 
 typ wbudowany w Pythonie to bool, lecz jest akceptowany dowolny obiekt w kontekstach logicznych, takich ja 
 wyrażenia kontrolujące instrukcje - if, while, operandy operatorów and, or i not.
 
 aby wyznaczy czy wartość x jest truthy czy falsy, Python stosuje bool(x), co zawsze zwraca True lub False.
 
 Domyślne wystąpienia klas definiowanych przez użytkownika są uważana jako truthy, o ile nie mają zaimplementowanych metod __bool__ ani __len__
 
 zasadzniczo bool(x) wywołuje x.__bool__i wykorzystuje wynik tej metody.
 jeś metoda __bool__ nie jest zaimplementowana Python próbuje wywołać metodę x.__len__(), a jeśli ona zwraca zero, to bool zwraca False, w przeciwnym razie boo zwraca True.
 
 w naszym przykładzie implementacja metody __bool__jest koncepcyjnie prosta - zwraca False gdy moduł wektora jest równy zero, a w przeciwnym wypadku True.
 
 konwertujemy moduł na Boolean przy użyciu bool(abs(self)) - ponieważ metoda __bool__ ma zwracać zgodnie z oczekiwaniem typ logiczny.
 
poza metodą __bool__ rzadko zdarza się konieczność jawnego wywołania bool(), gdyż każdego obiektunayć w kontekscie logicznym.

można zauważyć że specjalna metoda __bool__ pozwala obiektom na spójność z regułami testowania wartości prawdy które są zdefiniowane w dokumentacji Pythona -

Truth Value Testing
https://docs.python.org/3/library/stdtypes.html#truth

można też wykreować szybszą implementację Vector.__bool__

def __bool__(self):
	return bool(self.x or self.y)
	

API kolekcji

interfejs podstawowych typów kolekcji występujących w języku
wszystkie klasy to ABC - abstrakcyjne klasy bazowe.

każda z najwyższych klas ABC zawiera pojedynczą metodę specjalną.
klasa ABC Collection - od Pythona 3.6 - unifikuje trzy kluczowe interfejsy, które powinna implementować każda kloekcja 

- Iterable - obsługa for, rozpakowywania* i innych form iteracji

	     * 4.8.5. Unpacking Argument Lists
	       https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists

- Sized - wsparcie wbudownej funkcji len
- Container - obsługa operatora in

Python nie wymaga od konkretnych klas, aby rzeczywiście wywodziły się z której kolwiekz tych klas ABC

Dowolna klasa implementująca __len__ spełnia wymagania interfejsu Sized

Ważne specjalizacje Collection:

Sequence - formalizuje interfejs wbudowanych funkcji, takich jak list i str
Mapping - implementowane przez dict, collections.deaultdict itp
Set - interfejs typów wbudowanych set i frozenset

tylko klasa Sequence jest Reversible - gdyż sekwencje wspierają dowolne porządkowanie swojej zawartości- czego nie obsługują odwzorowania ani zbiory

począwszy od Pythona 3.7 dict jest oficjalnie uporządkowany - tzn. zachowana jest kolejność wstawiania kluczy - nie można zmienić kolejności kluczy w dict wg własnego życzenia

przegląd metod specjalnych

Data model
https://docs.python.org/3/reference/datamodel.html

2. Tablica sekwencji

Python odziedziczył z ABC (językiem ABC) ujednoliconą obsługę sekwencji

Łańcuchy, listy, sekwencje bajtów, tablice, elementy XML i wyniki baz danych współdzielą bogaty zbiór operacji, obejmujący iteracje, wycinanie, sortowanie i łączenie 

zrozumienie list oraz podstawy wyrażeń generatorów
używanie krotek jako rekordów kontra ich wykorzystywanie jako niezmiennych list
rozpakowywanie sekwencji i wzorce sekwencji
czytanie i zapisywanie wycinków
specjalizowane typy sekwencji, jak tablice i kolejki


zarządzanie uporządkowanymi sekwencjami za pomocą bisect
https://www.fluentpython.com/extra/ordered-sequences-with-bisect/

przegląd wbudowanych sekwencji

biblioteka standardowa oferuje wiele typów sekwencji zaimplementowanych w języku C:

Sekwencje kontenerowe - przechowują elementy różnych typów, włącznie z innymi kontenerami
np. list tuple i collections.deque

Sekwencje płaskie - przechowują elementy jednego typu
np. str, bytes i array.array

Sekwencje kontenerowe - przechowują odwołania do zawartych w sobie obiektów, które mogą być dowolnego typu

sekwencje płaskie są bardziej upakowane, lec przy tym ograniczone do przechowywania prymitywnych wartości - takich jak znaki, bajty i liczby

każdy obiekt Pythona w pamięcia zawiera nagłówek z metadanymi
najprostszy obiekt Pythona - float, ma pole wartości oraz dwa pola metadanych:
ob_refcnt - licznik referencji do obiektu
ob_type - wskaźnik do typu obiektu
ob_fval - liczba double języka C, przechowywująca wartość

https://docs.python.org/3/c-api/typeobj.html#slot-type-typedefs

w 64-bitowe kompilacji Pythona każde z tych pól zajmuje 8 bajtów.

tablica float jest bardziej zwarta, niż krotka z tymi samymi wartościami.
tablica to pojedynczy obiekt przechowywujący surowe wartośc, podcas gdy krotka składa się z wielu obiektów - siebie samej oraz każdego obiektu float w niej zawartego


innym sposobem grupowania sekwencji jest ich zmienność

Sekwencje zmienne
list byte.array, array.array, i collections.deque

Sekwencje niezmienne
tuple, str i bytes



Wyrażenia listowe i wyrażenia generatora
szybkim sposobem na zbudowanie sekwencji jest użycie wyrażenia listowego - gdy celem jest list - lub wyrażenia generatora - dla wszystkich innych rodzajów sekwencji.

nie używając tych form syntaktycznych - nasz kod jest mniej czytelny, również mniej szybszy

w środowisku Pythona
wyrażenia listowe - to listcomp
wyrażenia generatora - to genexp

Przykład 2-1

Przykład 2-2

bardziej czytelny przykładem jest przykład 2-2


zastosowanie pętli for
do skanowania sekwencji, aby zliczać lub wybierać elementy
obliczanie agregacji - sum, średnich
przetwarzanie

kod 2-1 buduje listę
w 2-2 jest zastosowane wyrażenie listowe - jego zadaniem jest budowanie listy

w przypadku stosowania wyrażeń listowych, należy brać pod uwagę aby to wyrażenie nie miało więcej niż dwa wiersze i było zwięzłe


w kodzie Pythona podziały wierszy są ignorowane wewnątrz parnawiasów []{} lub ()
jest możliwe budowanie wielowierszowych list, wyrażeń listowych i generatorów, słowników itp. bez używania znaku ucieczki \ do oznaczania kontynuacji wiersza.
stosując \ nie wolno umieścić po nim żadnego znaku - nawet spacji

kodując wielowierszowy literał listowy należ zadbać aby po ostatniej pozycji umieścić przecinek -
aby nie tworzyć zamętu przy wyszukiwaniu różnic


---------------------------------------------------
Lokalny zasięg w wyrżeniach listowych i generatora

w Pytchonie 3 wyrażenia listowe, wyrażenia generatora, wyrażenia zbiorów - setcomp - oraz słownikowe - dictcomp, mają zasięg lokalnydo przechowywania zmiennych przypisanych w klauzuli for

zmienne przypisane za pomocą 'operatora morsa' := pozostają dostępne po powrocie z tych wyrażeń - w przeciwieństwie do lokalnych zmiennych funkcji

PEP 572 – Assignment Expressions
https://peps.python.org/pep-0572/

przykład 1

x = 'ABC'
codes = [ord(x) for x in x]
x
'ABC'
codes
[65, 66, 67]

x - jest powiązany z 'ABC' - nie jest oderwany

przykład 2

codes = [last := ord(c) for c in x]
last
67
c
Traceback (most recent call last):
  File "/snap/pycharm-community/323/plugins/python-ce/helpers/pydev/pydevconsole.py", line 364, in runcode
    coro = func()
  File "<input>", line 1, in <module>
NameError: name 'c' is not defined

last jest widoczne poza zakresem
c - nie jest widoczne poza zakresem

---------------------------------------------------

wyrażenia listowe budują listy na podstawie sekwencji lub dowolnego innego typu iterowalnego za pomocą filtrowania i transformcji elementów.
to samo można realizować za moca wbudowanych funkcji filter i map


Wyrażenia listowe a funkcje filter i map

Przykład 2-3
budowanie listy  za pomocą wyrażenia listowego i złożenia funkcji map-filter

>>> symbols = '$¢£¥€¤'
>>> beyond_ascii = [ord(s) for s in symbols if ord(s) > 127]
>>> beyond_ascii
[162, 163, 165, 8364, 164]



>>> beyond_ascii = list(filter(lambda c: c > 127, map(ord, symbols)))
>>> beyond_ascii
[162, 163, 165, 8364, 164]



test szybkości 
https://github.com/fluentpython/example-code-2e/blob/master/02-array-seq/listcomp_speed.py

Iloczyny kartezjańskie
wyrażenia listowe mogą generować listy na podstawie iloczynu kartezjańskiego dwóch obiektów iterowalnych lub większej ich liczby.

elementy składające się na iloczyn kartezjański to krotki powstałe z elementów pochodzących z każdego wejściowego obiektu iterowalnego.

wynikowa lista ma długość równą przemnożonym długością wejściowych obiektów iterowalnych

iloczyn kartezjański sekwencji trzech wartości kart i sekwencji czterech kolorów, w wyniku daje sekwencję dwanastu par

 
przykład iloczynu kartezjańskiego z zastosowaniem wyrżeni listowego

>>> colors = ['black', 'white']
>>> sizes = ['S', 'M', 'L']
>>> tshirts = [(color, size) for color in colors for size in sizes]
generuje listę krotek uporządkowanych wg koloru - color, a następnie rozmiaru - size
>>> tshirts
[('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), ('white', 'M'), ('white', 'L')]

taka lista jest porządkowana tak, jakby pętle for były zagnieżdżone w tej samej kolejności, w jakiej występują w wyrażeniu listowym

>>> for color in colors:
...     for size in sizes:
...             print((color, size))
... 
('black', 'S')
('black', 'M')
('black', 'L')
('white', 'S')
('white', 'M')
('white', 'L')

aby uporządkować elementy wg rozmiaru, a następnie koloru, należy zmienić kolejność klauzul for.
zmiana sposobu zapisu wyrażenia listowego poprawia czytelność wyrażenia

>>> tshirts = [(color, size) for size in sizes
...                          for color in colors]
>>> tshirts
[('black', 'S'), ('white', 'S'), ('black', 'M'), ('white', 'M'), ('black', 'L'), ('white', 'L')]


w przykładzie 1-1
    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]
        
dla poprawienia czytelności = można ją zapisać:

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits 
        				for rank in self.ranks]
        				

wyrażenia listowe mają tylko jedno zastosowanie: budują listy
        


mamty konstrukcję
 str 27 (58)
